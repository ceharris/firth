CODE "if",2,msk_immed,if
    ENTER
    dw lbrace
    dw lit, QBRAN, comma              ; compile ?branch
    dw here, fetch, DUPP, comma          ; compile here and also push on stack
    EXIT

CODE "else",4,msk_immed,else
    ENTER
    dw lit, BRAN, comma               ; definite branch to just over the false-part
    dw here, fetch                      ; save here on stack
    dw lit, 0, comma                    ; compile a dummy offset
    dw swap                             ; now back-fill the original (if) offset
    dw xendif                           ; must call xendif not endif
    EXIT

CODE "endif",5,msk_immed,endif
    ENTER
    dw xendif                           ; must call xendif not endif
    dw rbraceExec
    EXIT

xendif:                                 ; must call xendif not endif
    ENTER
    dw DUPP
    dw here, fetch, swap, SUBB         ; calculate the offset from the address saved on the stack
    dw swap, store                      ; store the offset in the back-filled location
    EXIT

; begin condition while ... repeat

CODE "begin",5,msk_immed,begin
    ENTER
    dw lbrace
    dw here, fetch                      ; save here on stack (here1)
    EXIT

CODE "while",5,msk_immed,while
    ENTER
    dw lit, QBRAN, comma              ; compile branch on zero
    dw here, fetch                      ; save here in stack (here2)
    dw lit, 0, comma                    ; compile dummy offset
    EXIT

CODE "repeat",6,msk_immed,repeat
    ENTER
    dw lit, BRAN, comma               ; compile branch
    dw swap                             ; tos = here1
    dw here, fetch, SUBB, comma        ; compile offset (here1 - here3)
    dw DUPP
    dw here, fetch, swap, SUBB         ; compile offset (here2 - here3)
    dw swap, store                      ; save offset in here2
    dw rbraceExec
    EXIT

; ?branch   x --              branch if TOS zero
CODE "?branch",7,0,QBRAN
    checkZeroWord B,C               ; test old TOS
    ppop0 B,C                       ; POP new TOS
    jr z,BRAN                     ; if old TOS=0, branch
    pop HL
    inc HL                          ; else skip inline value
    inc HL
    NEXT1

CODE "branch",6,0,BRAN         ; relative branching
    pop HL                          ; add the offset to the instruction pointer
    ld E,(HL)
    inc HL
    ld D,(HL)
    dec HL
    add HL,DE
    NEXT1

; ?branch   x --              branch if TOS zero
CODE "?branch1",7,0,QBRAN1
    checkZeroWord B,C               ; test old TOS
    ppop0 B,C                       ; POP new TOS
    jr z,BRAN1                     ; if old TOS=0, branch
    pop HL
    inc HL                          ; else skip inline value
    inc HL
    NEXT1

CODE "branch1",6,0,BRAN1         ; relative branching
    pop HL                          ; add the offset to the instruction pointer
    ld E,(HL)
    inc HL
    ld D,(HL)
    EX DE,HL
    NEXT1

