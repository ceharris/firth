;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; words
;;
;; forth word defintions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mCODE "quit",4,0,quit
    ENTER
    dw sp0, fetch, spStore
    dw interpret
    EXIT

mCODE "word",5,0,WORD                 ; delim -- c-addr
    ENTER
    dw lit, 64                          ; limit
    dw here, fetch
    dw xword                            ; writes to HERE!
    EXIT

mCODE ">cfa",4,0,tcfa
    ENTER
    dw lit, 2, plus
    dw count
    dw lit, msk_length, and
    dw plus
    EXIT

; count extract string length from pascal string  ( ptr -- ptr+1 len )
mCODE "count",5,0,count
    ENTER
    dw dup, lit, 1, plus                ; ( ptr -- ptr ptr+1)
    dw swap, cfetch                     ; ( ptr ptr+1 -- ptr+1 len)
    EXIT

; allocate n bytes of memory                                   ( n -- ) allocate n bytes of memory
mCODE "allot",5,0,allot               ;
    ENTER
    dw here, addstore                   ; adds n to here
    EXIT

; abs   n -- u                          absolute value
mCODE "abs",3,0,ABS                   ; case sensitive for ABS label for some reason
    ENTER
    dw dup                              ; copy arg
    dw zeroless
    cif
        dw negate                       ; if signs differ then negate answer
    cendif
    EXIT

; negate  n1 -- n2                      negate n1
mCODE "negate",6,0,negate
    ENTER
    dw invert
    dw oneplus
    EXIT

mCODE "bl",2,0,bl
    ENTER
    dw lit, $20                         ; compile branch on zero
    EXIT

mCODE "interpret",6,0,interpret
    rst $08
    cDo
    	dw bl, word, count        ; pstr -- ptr len
        dw dup, zEqual
        cIf
            dw drop, drop                           ; ptr len --
            EXIT
        cEndif
        dw interpToken                       ; interpret the next word
    cEndDo
    EXIT

mCODE "'",1,0,tick                    ; quotes next word
    dw bl,word,find,zEqual
    dw rFrom,count,over,over,plus,toR
    dw EXIT

mCODE "*",1,0,star                    ; u1 u2 -- ud
    ENTER
    dw over, over                       ; dupe both args
    dw ABS, swap, ABS                   ; remove sign from both args
    dw ustar, drop                      ; unsigned multiply, drop hi-word
    dw nrot                             ; move to bottom
    dw xor                              ; zero if signs are the same
    dw zeroless                         ; if high bit set
    cif
        dw negate                       ; if signs differ then negate answer
    cendif
    EXIT

mCODE "/mod",4,0,slashmod             ; dvend dvisr -- rem quot
    ENTER
    dw over, over                       ;       u1 u2 -- u1 u2 u1 u2  dupe both args
    dw xor                              ; u1 u2 u1 u2 -- u1 u2 b1     xor hi bits
    dw zeroless                         ; true if high bit still set
    dw nrot                             ;    u1 u2 b1 -- b1 u1 u2     move to bottom

    dw over                             ;    b1 u1 u2 -- b1 u1 u2 u1  dupe dividend
    dw zeroless                         ; b1 u1 u2 u1 -- b1 u1 u2 b2  zero if signs are the same
    dw nrot                             ; b1 u1 u2 b2 -- b1 b2 u1 u2  move to bottom

    dw ABS, swap, ABS, swap             ; remove sign from both args
    dw uslashmod                        ; b1 b2 u1 u2 -- b1 b2 r q    unsigned divide (remainder, quotient)
    dw swap                             ; b1 b2 u1 u2 -- b1 b2 q r
    dw rot                              ; b1 b2 q r -- b1 q r b2      bring to top
    cif
        dw negate                       ;   b1 q r b2 -- b1 q -r      if -ve then negate answer
    cendif
    dw nrot                             ;     b1 q -r -- -r b1 q     bring to top
    dw swap                             ;     -r b1 q -- -r q b1      bring to top
    cif
        dw negate                       ;     -r q b1 -- -r -q       if signs differ then negate answer
    cendif
    EXIT

mCODE "/",1,0,slash                   ; dvend dvisr -- quot
    ENTER
    dw slashmod
    dw swap, drop                       ; drop remainder
    EXIT

mCODE "mod",3,0,mod                   ; dvend dvisr -- remainder
    ENTER
    dw slashmod
    dw drop                             ; drop quotient
    EXIT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; flow control
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mCODE "if",2,msk_immed,if
    ENTER
    dw lbrace
    dw lit, zbranch, comma              ; compile 0branch
    dw here, fetch, dup, comma          ; compile here and also push on stack
    EXIT

mCODE "else",4,msk_immed,else
    ENTER
    dw lit, branch, comma               ; definite branch to just over the false-part
    dw here, fetch                      ; save here on stack
    dw lit, 0, comma                    ; compile a dummy offset
    dw swap                             ; now back-fill the original (if) offset
    dw xendif                           ; must call xendif not endif
    EXIT

mCODE "endif",5,msk_immed,endif
    ENTER
    dw xendif                           ; must call xendif not endif
    dw rbraceExec
    EXIT

xendif:                                 ; must call xendif not endif
    ENTER
    dw dup
    dw here, fetch, swap, minus         ; calculate the offset from the address saved on the stack
    dw swap, store                      ; store the offset in the back-filled location
    EXIT

; begin condition while ... repeat

mCODE "begin",5,msk_immed,begin
    ENTER
    dw lbrace
    dw here, fetch                      ; save here on stack (here1)
    EXIT

mCODE "while",5,msk_immed,while
    ENTER
    dw lit, zbranch, comma              ; compile branch on zero
    dw here, fetch                      ; save here in stack (here2)
    dw lit, 0, comma                    ; compile dummy offset
    EXIT

mCODE "repeat",6,msk_immed,repeat
    ENTER
    dw lit, branch, comma               ; compile branch
    dw swap                             ; tos = here1
    dw here, fetch, minus, comma        ; compile offset (here1 - here3)
    dw dup
    dw here, fetch, swap, minus         ; compile offset (here2 - here3)
    dw swap, store                      ; save offset in here2
    dw rbraceExec
    EXIT

; using {"s",$22} because it's surprisingly difficult
; to define the name s" using asm80
mCODE {"s",$22},2,msk_immed,squote
    jr qt

mCODE $22,1,msk_immed,qt
    ENTER
    dw state, fetch, zequal
    cIf
        dw lit, $22                     ; delim
        dw lit, 63                      ; limit 63 + length
        dw latestStr, fetch
        dw lit, wordBuf, equal
        cIf
            dw lit, wordBuf2
        cElse
            dw lit, wordBuf
        cEndIf
        dw latestStr, store             ; store here in latestStr
        dw latestStr, fetch
        dw xword, count
    cElse
        dw lit, litstr, comma
        dw lit, $22, word
        dw cfetch, oneplus
        dw allot
    cEndif
    EXIT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; non-standard words
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mCODE "{",1,msk_immed,lbrace
    ENTER
    dw state, fetch, zEqual
    dw nesting, fetch, zEqual
    dw and
    cIf
        dw here, fetch                  ; TOS = here
        dw lit, rst08_opcode, ccomma    ; write z80 jp opcode to word
    cEndIf
    dw nestPlus                         ; increase nesting
    EXIT                             ; return from the function.

mCODE "}",1,msk_immed,rbrace
    ENTER
    dw nestMinus                        ; reduce nesting
    dw state, fetch, zEqual
    dw nesting, fetch, zEqual
    dw and
    cIf
        dw lit, exit, comma                 ; append exit (so the word will return).
    cEndIf
    EXIT                             ; return from the function.

mCODE "}exec",5,msk_immed,rbraceExec
    ENTER
    dw rbrace
    dw state, fetch, zEqual
    dw nesting, fetch, zEqual
    dw and
    cIf
        dw dup
        dw here, store
        dw execute
    cEndIf
    EXIT                             ; return from the function.

