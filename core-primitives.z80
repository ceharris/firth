; ; words must preserve: BC, DE, SP, IX
; ; words may destroy: HL, IY, AF, AF', BC', DE' HL'

mCODE "xword",6,0,xword               ; delim limit addr -- c-addr
    call xwordSkip
    call xwordRead
    NEXT

mCODE "find",4,0,FIND
    ppop0 H,L

    call lookup                     ; params: HL = string address, BC = string length
                                    ; returns: DE = found header ptr or 0
    loadWord B,C, D,E               ; move to TOS
    NEXT

mCODE "execute",7,0,EXECUTE
    ppop H,L                        ; POP TOS into HL
    jp (hl)                         ; go do Forth word

mCODE "number",6,0,NUMBER         ; ( ptr len -- num err )
    ppop0 H,L
	call toNumber                   ; params: HL = string address, BC = string length
			                        ; Returns the parsed number in DE,
	                                ; BC = 0, success
    ppush0 D,E
    NEXT

mCODE "+!",2,0,ADDSTORE               ; (n addr -- )
	ppop H, L		            ; HL = address, TOS = amount to add
	ld A,(HL)
	add A,C                         ; add TOS at (HL),
	ld (HL),A
	inc HL
	ld A,(HL)
	adc A,B
	ld (HL),A
	ppop0 B,C                      ; clear param stack
    NEXT

mCODE "hidden",6,0,HIDDEN
    ppop H,L		            ; HL = Dictionary entry.
    inc HL
    inc HL                      ; Point to name/flags byte.

    ld A, (HL)
    xor MSK_HIDDEN        	    ; Toggle the HIDDEN bit.
    ld (HL), A
    NEXT

; ?branch   x --              branch if TOS zero
mCODE "0branch",7,0,ZBRANCH
    checkZeroWord B,C               ; test old TOS
    ppop0 B,C                       ; POP new TOS
    jr z,BRANCH                     ; if old TOS=0, branch
    pop HL
    inc HL                          ; else skip inline value
    inc HL
    NEXT1

mCODE "branch",6,0,BRANCH         ; relative branching
    pop HL                          ; add the offset to the instruction pointer
    ld E,(HL)
    inc HL
    ld D,(HL)
    dec HL
    add HL,DE
    NEXT1

mCODE "lit",3,0,LIT
	ppush0 B,C                      ; pushTOS
	pop HL                          ; pop address of next Forth word in HL
	readWord HL, B,C                ; read next word and push on TOS, inc HL by 2
    NEXT1

mCODE ",",1,0,COMMA
	ld HL, (VAR_HERE)	; HERE
	writeWord HL, B,C
	ld (VAR_HERE), HL	; Update HERE (incremented)
	ppop0 B,C		        ; cleanup TOS
    NEXT


; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;
; ;; memory access
; ;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


mCODE "c,",1,0,CCOMMA
    ppush0 H,L
	ld HL, (VAR_HERE)	; HERE
	ld (HL), C          ; Store DE at memory pointed to by VAR_HERE
	inc HL
	ld (VAR_HERE), HL	; Update HERE (incremented)
    ppop0 H,L
	ppop0 B,C		        ; cleanup TOS
    NEXT



mCODE "[",1,MSK_IMMED,LBRAC
	ld HL, 0
	ld (VAR_STATE), HL	; Set STATE to 0.
    NEXT

mCODE "]",1,0,RBRAC
	ld HL, 1
	ld (VAR_STATE), HL	; Set STATE to 1.
    NEXT


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; stack
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; output
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


    
    ; dw dup, 0<                      ; ptr data data 
    ; cIf                             
    ;     dw swap                     ; data ptr 
    ;     dw dup, lit, '-'            ; data ptr ptr '-'
    ;     dw swap, store              ; data ptr
    ; cEndif
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HL = data, DE = ptr to lineBuf, C = base ***
; DE = ptr to string, BC = length
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; formatNumber:                       ; base data ptr -- ptr length
    ; bit 7, H
    ; _if nz
    ;     ; HL is negative. Output '-' to string and negate HL.
    ;     ld A, '-'
    ;     ld (DE), A
    ;     inc DE
    ;     call negateNum
    ; _endif

    ; ld B, 0     ; B will count character length of number
    ; _do
    ;     push BC
    ;     call divideWordByByte  ; HL = HL / A, A = remainder
    ;     pop BC
    ;     push AF
    ;     inc B
    ;     checkZeroWord H,L
    ; _until z
    ; _enddo
    ; _do
    ;     pop AF
    ;     add A,$30                     ; convert digit to ASCII
    ;     cp $3A
    ;     _if nc
    ;         add A,7
    ;     _endif
    ;     ld (DE), A
    ;     inc DE
    ; _djnz

    ; ld HL,wordBuf           ;calc length
    ; ex DE,HL
    ; or A
    ; sbc HL,DE
    ; loadWord B,C, H,L
    ; ret


